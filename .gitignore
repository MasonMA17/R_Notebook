# History files
.Rhistory
.Rapp.history

# Session Data files
.RData

# User-specific files
.Ruserdata

# Example code in package build process
*-Ex.R

# Output files from R CMD build
/*.tar.gz

# Output files from R CMD check
/*.Rcheck/

# RStudio files
.Rproj.user/

# produced vignettes
vignettes/*.html
vignettes/*.pdf

# OAuth2 token, see https://github.com/hadley/httr/releases/tag/v0.3
.httr-oauth

# knitr and R markdown default cache directories
*_cache/
/cache/

# Temporary files created by R markdown
*.utf8.md
*.knit.md

# R Environment Variables
.Renviron

########################
# create our own functions----一般设置些简单条件创造想要的数据
pacman::p_load(tidyverse,FRACTION,lubridate)
EvenOdd=function(x=2){ if((x%%2)==0){return('Even')} else {return('Odd')}} #奇偶判定
AddFunc = function(x=2,y=2){x+y}
DoubleAdd=function(x=2,y=2){sum=AddFunc(x,y) return(2*sum)}  # Nested function

#Vectorising a Function-----创造函数后，我们往往需要直接判断一列（vector)的情况，而不是单个元素
lapply()
tapply() #avoid using loop
rowMeans()
colMeans() #this two example also could create a vector, notice"s"

x[is.na(x)]=0  #subsetting also can help vectorize a function/ or use lookup
#subsetting example
emp=c('XX','L','DM','SE','SSE')
emp=sample(emp,1000000,replace=T)
designation_employees=function(emp){ 
for(i in 1:length(emp)){ 
if (emp[i]=="DM"){emp[i]="Delivery Manager"
} else if (emp[i]=="L"){emp[i]="Lead"
} else if (emp[i]=="SFE"){emp[i]="Snr.Soft.Eng."
} else if(emp[i]=="SE"){emp[i]="Soft.Eng"
} else {emp[i]="Intern/Trainee"}
}emp}   ##such a heavy job!
#lookup tables
designation_employee3= function(emp){
result= c("DM"="Delivery Manager","L"="Lead",
"SFE"="Snr.Soft.Eng.","SE"="Soft.Eng","xx"="Intern/Trainee")
unname(result[emp])}
benchmark(designation_employees3(emp),replications=10)

##use mapply&vectorize
mapply(Function,...,MoreArgs=NULL,SIMPLIFY=TRUE, USE.NAMES=TRUE) #use mapply
benchmark(mapply(designation_employees,emp))

vec_designation_emp=Vectorize(designation_employees,c('emp'))
benchmark(vec_designation_emp(emp))

#Profiling Code
system.time() #to get the amount of time taken to evaluate an expression 即用来评估效率
install.packages('rbenchmark') #for comparing commands
install.packages('microbenchmark')#for high precision measurements
Rprof()
summaryRprof()  ## for investigate larger chunks of code such as lm()

####### Wide&Long Data------把不同列转为不同行
#pipe fuction-管道函数
%>%  # 将左边的结果传递到右边，一般右边是一个函数
%<>% #也是将左边的结果传递给右边，但是这个操作符会将最后的结果返回给最开始的变量。
%T>% #将左边的结果传递到右边，但返回原始的结果，or是返回上一级结果。
%$%  #左边一般不是变量，而是数据框or列表
%in% #匹配，相当于R中的match函数，左边的元素在右边的向量中是否存在，返回TRUE OR FALSE
#解决column名称中”X2016“分开问题
separate(Year,into=c("x","Year"),sep="X") %>% select(-x) %>% mutate(Year=as.numeric(Year))
f1=read.csv('f1.csv',check.names = F) #another method
#convert to a long data format
gather(df_to_reshape,new_col_key,new_col_value,cols_to_get_values,args(na.rm=FALSE,convert=FALSE))
f1New=gather(f1,'year','count'2:ncol(f1))
head(f1New) 
saplly(f1New,class) #看变量格式，以上的公式里year格式为”character"
f1New=f1%>%gather('year','count',2:ncol(f1),convert=T) #这种情况year格式为“integer”
f1New=f1%>%gather('year','count',2:ncol(f1),convert=T)%>%rename('categories'=Variables)%>%arrange(categories) #重命名+排序

###### Date&Time
Sys.time() #看系统时间
class(Sys.time())
Sys.Date() #只显示年月日
class(Sys.Date)
Sys.timezone() #时区
dates=c("March 27,1987","June 11,1960") #character type
Newdates=as.Date(dates,format="%B,%d,%Y") #转换格式必须要这种格式

timeNow='13-02-2018 9:20' #格式 character
timeNow_tz = dmy_hm(timeNow) #更改成功
timeNow_tz=force_tz(time_tz,"Asia/Kuala_Lumpur") #change timezone
with_tz(time_tz,"Asia/KOLKATA" #convert to desired time zone

year(),month(),wday(),hour(),minute(),second() #显示年月日等

# Work with the inerval
time1=force_tz(time_tz,"Asia/Kuala_Lumpur") #确保时区是相同的
time2=force_tz(time_tz,"Asia/Kuala_Lumpur")
interval=interval(time2,time1)  #create an interval
interval/ddays(1) #days
interval/dhours(1) #hour
interval/weeks(1)  #weeks
interval/dyears(1) #years

####### 练习 两张表“Lekagul Sensor Data" and "coordinates"
pacman::p_load(tidyverse,lubridate)
file1 = 'Lekagul Sensor Data.csv'
file2 = 'coordinates.csv'
data = read.csv(file1, stringsAsFactor = F) #拒绝分类
coordinates = read.csv(file2, stringsAsFactor = F)
lapply(list(data, coordinates), str)
data = data %>%rename(FromTime = Timestamp,FromGate = gate.name,Vehicle = car.type,ID = car.id) #重命名
data$FromTime = dmy_hm(data$FromTime) #correct data types
data[, c('FromGate', 'Vehicle')] = lapply(data[, c('FromGate', 'Vehicle')], factor)#设置分类
data_unique = data%>%distinct() #去除重复值
data_unique = data_unique%>%mutate(SecondsSpent = interval(FromTime,ToTime)/dseconds(1)) #添加新的列并计算时间区间

######画图——ggplot2
#fundamental factors: Data, Mapping(映射),Geometric(几何对象),Scale(标尺),
#Statistics,Coordinante(坐标系统),Layer(图层),Facet(分面),Theme(主题)
p<-ggplot(data=df,mapping=aes(x=col,t=col,shape=col,colour=col))#shape可以将某元素反应到形状上
p+geom_point() #散点图
p<-ggplot(df)
p+geom_point(aes(x=col,t=col,shape=col,colour=col)) #与之前的两步结果一样
ggplot(df)+geom_histogram(aes(x=col,fill=col),position="") #直方图，其中fill为填充颜色，position为分为side by side
ggplot()+geom_bar(aes(x=c(LETTERS[1:3]),y=1:3), stat="identity") #柱状图 stat使按照指定高度画图
ggplot()+geom_density(aes(x=col, colour=col,fill=col)) #密度函数图
ggplot(small)+geom_boxplot(aes(x=cut, y=price,fill=color)) #箱式图
geom_abline 	geom_area 	
geom_bar 		geom_bin2d
geom_blank 		geom_boxplot 	
geom_contour 	geom_crossbar
geom_density 	geom_density2d 	
geom_dotplot 	geom_errorbar
geom_errorbarh 	geom_freqpoly 	
geom_hex 		geom_histogram
geom_hline 		geom_jitter 	
geom_line 		geom_linerange
geom_map 		geom_path 	
geom_point 		geom_pointrange
geom_polygon 	geom_quantile 	
geom_raster 	geom_rect
geom_ribbon 	geom_rug 	
geom_segment 	geom_smooth
geom_step 		geom_text 	
geom_tile 		geom_violin
geom_vline

ggplot(small)+geom_point(aes(x=carat, y=price, shape=cut, colour=color)
)+scale_y_log10()+scale_colour_manual(values=rainbow(7))  #通过scale进行控制

ggplot(small, aes(x=carat, y=price))+geom_point()+scale_y_log10()+stat_smooth() #对原始数据进行计算并加一条回归线
stat_abline       stat_contour      stat_identity     stat_summary
stat_bin          stat_density      stat_qq           stat_summary2d
stat_bin2d        stat_density2d    stat_quantile     stat_summary_hex
stat_bindot       stat_ecdf         stat_smooth       stat_unique
stat_binhex       stat_function     stat_spoke        stat_vline
stat_boxplot      stat_hline        stat_sum          stat_ydensity

ggplot(small)+geom_bar(aes(x=cut, fill=cut))+coord_flip() #coord_flip实现坐标翻转
coord_polar(theta="y") #转换成极坐标 这时会出现饼图
ggplot(small)+geom_bar(aes(x=factor(1), fill=cut))+coord_polar() #靶心图
ggplot(small)+geom_bar(aes(x=clarity, fill=cut))+coord_polar() #风玫瑰图
ggplot(small, aes(x=carat, y=price))+geom_point(aes(colour=cut)
)+scale_y_log10() +facet_wrap(~cut)+stat_smooth()    #facet_wrap 用来分组

ggtitle(),xlab(),ylab() #标题
theme_economist theme_economist_white # 一些系统给到的主题
theme_wsj 	 	theme_excel
theme_few 	 	theme_foundation
theme_igray 	theme_solarized
theme_stata 	theme_tufte

######String manipulations---字符串操作
str_count(x,pattern)
str_delet(x,pattern)
str_locate() str_locate_all()
str_extract()
str_match()
str_replace(x,pattern,replacement)
str_split(x,pattern)  str_split_fixed(x,pattern)

pacman::p_load(tidyverse,rebus,stringdist)
#rebus: SPC:\\s  DOT:.  START:^  END:$  DGT:\\d ALPHA: [:alpha:]
str_to_lower(x)
str_to_upper()
str_squish() #恢复原值
str_detect(x,pattern)

p=or('p','k')%R% END # (?:p|k)$
str_which(x,pattern=o) #显示位置
str_subset(x,pattern=p,negate=T) # negate 表示除了满足P以外的，显示的是元素

#数字为’219 733 8965' ‘234.252.3633'
p1= DGT %R% DGT %R% DGT
p2= DGT %R% DGT %R% DGT
p3= DGT %R% DGT %R% DGT %R%
sep = or(" ”,“.","-","")
ptrn=p1 %R% sep %R% p2 %R% sep %R% p3

str_match(x,pattern=ptrn) # 清洗不干净的数据
sep=char_class('.-')
str_replace_all(nums,pattern=sep,replacement="") #把"."也清洗掉

# values=c('male','M','amle',Female','Femle') 
correct_values= c('M','F')  

adist()  #native packages
amatch()  #Stringdist package
ind= amatch(values,correct_values,maxDist=5)
df=data.frame(initial = values,new_gender = correct_values[ind])  #会将values里的值自动更正为”M“


#####Consistent Data
duplicated(x) 
anyDuplicated()  #返回true值
x[!duplicated(x)] #去除重复值
distinct()
unique()

##Data Imputation
#Impute Missing Data
is.na(),is.nan(),is.infinity()
md.pattern() #mice package-examine the missing pattern ---other packages: mice,mi,Amelia

##例子
cars=read.csv('cars_missing.csv')
original=read.csv('cars.csv')

lapply(list(cars,original),summary)
cols=c('MetColor','Automatic','Doors')
cars[,cols]=lapply(cars[,cols],factor)  #设置分类函数
summary(cars)
#examine missing patterns
pacman::p_load(tidyverse,VIM,mice,Hmisc,DMwR)
library("mi")
library("Amelia")
library("mice")
md.pattern(cars)  #examine the missing pattern
df=as.data.frame(abs(is.na(cars)))
head(df,4)

#用图形探究
aggr(sleep,prop=FALSE,numbers=TRUE) #prop当为TRUE时，显示为缺失值的占比；当为FALSE时，显示为缺失值的数量
#numbers:是否显示数值，默认为FALSE，不显示缺失值的占比或数量
marginplot(sleep[,c('Gest','Dream')],pch = c(20,1),col=c('darkgray','red','blue')) #散点图 红色箱图表示包含插补值之后的分布，灰色箱图表示有效点的分布。红色的空心点是插补之后的点。


#correaltion of missing with othor columns
missing_col=df[which(apply(df,2,sum)>0)]
cor(missing_col)  # look for correlation between columns with missing values to see if there is any further link
cor(cars[,sapply(cars,is.numeric)],missing_col,use = "pairwise.complete.obs") #行是可观测，列为缺失
#MCAR:missing completely at random MAR:missing at random  MNAR: missing not at random

#impute using central tendency
mean_imp=impute(cars$HP,mean)
mode_imp=impute(cars$MetColor,mode)
mice_imput=mice(cars[,!names(cars)%in% "Price"])  #填补missing data
mice_imput
m_out=complete(mice_imput) #for 2nd dataset use complete(mice_imput,2)
dim(m_out)
colMeans(is.na(m_out))  #最后看看有没有缺失值

#accuracy?
actuals=original$HP[is.na(cars$HP)] 
imputed=mean_imp[is.na(cars$HP)]
regr.eval(actuals,imputed) #结果为: mae mse rmse mape
# MSE: mean square error(均方误差）RMSE：前者加上了根号 MAE:mean absolute error（平均绝对误差）
#MAPE: mean absolute percentage error(平均绝对百分比误差）

#for categorical
actuals=original$MetColor[is.na(cars$MetColor)]
imputed=mode_imp[is.na(cars$MetColor)] #the 1st method
imputed=m_out[is.na(cars$MetColor),"MetColor"] ##the 2nd method
prop.table(table(actuals,imputed))  #用来比较真实与预测的误差



####去除outliers
pacman::p_load(tidyverse, DMwR)
cars = read.csv('cars.csv')
ggplot(cars,aes(Price)) + geom_histogram() #when negative distribution,we use 'log', when positive distribution,we use 'square'
ggplot(cars,aes(log(Price))) + geom_histogram() #use log

outliers = filter(cars, (abs(Price - median(Price)) > 2*sd(Price))) #确定outliers
dim(outliers)

cars_new = filter(cars, !(abs(Price - median(Price)) > 2*sd(Price))) #去除outliers
dim(cars_new)

#replace values
qnt = quantile(cars$Price, probs=c(.25, .75), na.rm = T) 
cap = quantile(cars$Price, probs=c(.05, .95), na.rm = T)
Th = 1.5 * IQR(cars$Price, na.rm = T)
cars$cap_price = 0
cars$cap_price = ifelse((cars$Price < (qnt[1] - Th)), cap[1], cars$Price)
cars$cap_price = ifelse((cars$Price > (qnt[2] + Th)), cap[2], cars$Price)  #set upper and lower bounds

cap
qnt

summary(cars)
dim(cars)

options(repr.plot.width=12, repr.plot.height=8) #设置环境变量
linear_model = lm(Price ~ ., data=cars) #线性模型
c_dist = cooks.distance(linear_model)  #库克距离：描述单个样本对整个模型的影响程度，越远影响越大，为outliers，一般为多变量
plot(c_dist, pch="*", cex=2, main="Influential Obs by Cooks distance") #plot cook's distance
abline(h = 4*mean(c_dist, na.rm=T), col="red")  #add cutoff line 
text(x=1:length(c_dist)+1, y=c_dist,labels=ifelse(c_dist>4*mean(c_dist, na.rm=T
),names(c_dist),""), col="red")  # add labels

influential = as.numeric(names(c_dist)[(c_dist > 4*mean(c_dist, na.rm=T))])  # look at influential row numbers
head(cars[influential, ])
dim(cars[influential, ])
dim(cars[-influential, ])

##异常因子检测
str(cars)
scores = lofactor(cars[, sapply(cars, is.numeric)], k =5) #lof :local outlier factor 检测cars中属于numeric的列（因为只对numeric数据有效
plot(density(scores))
outliers = order(scores, decreasing=T)[1:5] #挑出前五的异常值


